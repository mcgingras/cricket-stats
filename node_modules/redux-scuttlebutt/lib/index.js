'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.devToolsStateSanitizer = exports.UPDATE_SNAPSHOT = exports.UPDATE_SOURCE = exports.UPDATE_TIMESTAMP = exports.UPDATE_ACTION = exports.REWIND_ACTION = exports.META_TIMESTAMP = exports.META_SOURCE = exports.isGossipType = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _dispatcher = require('./dispatcher');

Object.defineProperty(exports, 'isGossipType', {
  enumerable: true,
  get: function get() {
    return _dispatcher.isGossipType;
  }
});

var _constants = require('./constants');

Object.defineProperty(exports, 'META_SOURCE', {
  enumerable: true,
  get: function get() {
    return _constants.META_SOURCE;
  }
});
Object.defineProperty(exports, 'META_TIMESTAMP', {
  enumerable: true,
  get: function get() {
    return _constants.META_TIMESTAMP;
  }
});
Object.defineProperty(exports, 'REWIND_ACTION', {
  enumerable: true,
  get: function get() {
    return _constants.REWIND_ACTION;
  }
});
Object.defineProperty(exports, 'UPDATE_ACTION', {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_ACTION;
  }
});
Object.defineProperty(exports, 'UPDATE_TIMESTAMP', {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_TIMESTAMP;
  }
});
Object.defineProperty(exports, 'UPDATE_SOURCE', {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_SOURCE;
  }
});
Object.defineProperty(exports, 'UPDATE_SNAPSHOT', {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_SNAPSHOT;
  }
});
exports.default = scuttlebutt;

var _dispatcher2 = _interopRequireDefault(_dispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Applies default options.
var defaultOptions = {
  uri: (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.location.protocol + '//' + window.location.host,
  primusOptions: {},
  primus: (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.Primus,
  dispatcherOptions: {}
};

// Store enhancer
// Wraps createStore to inject our history reducer, wraps dispatch to send and
// receive actions from peers, and FIXME: getState to apparently break everything
//
function scuttlebutt(options) {
  options = _extends({}, defaultOptions, options);

  return function (createStore) {
    // is it more efficient to store previous states, or replay a bunch of
    // previous actions? (until we have COMMIT checkpointing, the former)
    var dispatcher = new _dispatcher2.default(options.dispatcherOptions),
        scuttlebutt = connectGossip(dispatcher, options.uri, options.primusOptions, options.primus);

    return function (reducer, initialState, enhancer) {
      var store = createStore(scuttlebutt.wrapReducer(reducer), dispatcher.wrapInitialState(initialState), // preloaded state is the earliest snapshot
      enhancer);

      return _extends({}, store, {
        scuttlebutt: scuttlebutt,
        dispatch: scuttlebutt.wrapDispatch(store.dispatch),
        getState: scuttlebutt.wrapGetState(store.getState)
      });
    };
  };
}

// initialise network io
function connectGossip(scuttlebutt, uri, primusOptions, Primus) {
  scuttlebutt.io = Primus.connect(uri, primusOptions);

  console.log('[io] connecting...');

  connectStreams(scuttlebutt.io, function () {
    return scuttlebutt.createStream();
  });

  return scuttlebutt;
}

// the internet is a series of tubes
function connectStreams(io, createStream) {
  // would love to do this. it doesn't work:
  // spark.pipe(docStream).pipe(spark)

  var DEBUG_DELAY = void 0;
  if (/^#\d+/.test(window.location.hash)) {
    DEBUG_DELAY = parseInt(window.location.hash.substr(1));
    console.debug('delayed connection active', DEBUG_DELAY);
  }

  var gossip = void 0;

  // scuttlebutt uses 'stream', but primus does not, hence the lopsided pipe

  // io.on('data', function message(data) {
  //   // console.log('[io] <-', data)
  //   if (DEBUG_DELAY) {
  //     return setTimeout(() => gossip.write(data), DEBUG_DELAY)
  //   }
  //   gossip.write(data)
  // })

  // gossip.pipe(io)
  // gossip.on('data', (data) => {
  //   // console.log('[io] ->', data)
  //   if (DEBUG_DELAY) {
  //     return setTimeout(() => io.write(data), DEBUG_DELAY)
  //   }
  //   io.write(data)
  // })

  // network events

  io.on('open', function () {
    console.log('[io] connection open');

    // create fresh stream,
    // discard the old one (hopefullly .destroy()d on 'end')
    gossip = createStream();
    gossip.pipe(io);

    io.on('data', function message(data) {
      // console.log('[io] <-', data)
      if (DEBUG_DELAY) {
        return setTimeout(function () {
          return gossip.write(data);
        }, DEBUG_DELAY);
      }
      gossip.write(data);
    });

    io.on('end', function () {
      console.log('[io] ended');
      gossip.end();
      gossip.destroy();
    });

    // store stream events

    gossip.on('error', function (error) {
      console.warn('[gossip] error', error);
      io.end(undefined, { reconnect: true });
    });

    // handshake header recieved from a new peer. includes their id and clock info
    gossip.on('header', function (header) {
      var id = header.id,
          clock = header.clock;

      console.log('[gossip] header', id);
    });
  });

  io.on('error', function (error) {
    console.log('[io] error', error);
  });
}

// devToolsStateSanitizer can be applied to the devToolsExtension
// as the stateSanitizer to show correctly the store state instead
// of showing the internal representation of redux-scuttlebutt
var devToolsStateSanitizer = exports.devToolsStateSanitizer = function devToolsStateSanitizer(state) {
  return state.slice(-1)[0][_constants.UPDATE_SNAPSHOT];
};